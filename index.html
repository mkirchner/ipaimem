<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPAI Master Socialite</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            background-color: #dbe1e0;
            color: black;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
        }

        .header-logo {
            max-width: 300px;
            height: auto;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-bottom: 30px;
        }

        .nav-group {
            display: flex;
            gap: 10px;
        }

        nav button {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #c2cecb;
            color: black;
            transition: background-color 0.2s;
        }

        nav button:hover {
            background-color: #b3bfbc;
        }

        nav button.active {
            background-color: #d46e31;
            color: white;
            font-weight: 600;
        }

        nav button:disabled {
            background-color: #a8b2af;
            color: #6b7573;
            cursor: not-allowed;
            opacity: 0.6;
        }

        nav button:disabled:hover {
            background-color: #a8b2af;
        }

        nav button:disabled.active {
            background-color: #b86a3c;
            color: rgba(255, 255, 255, 0.7);
        }

        .section {
            display: none;
            background-color: #c2cecb;
            border-radius: 12px;
            padding: 25px;
        }

        .section.active {
            display: block;
        }

        .section h2 {
            font-weight: 700;
            margin-bottom: 20px;
            color: #d46e31;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input,
        .form-group select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 10px;
            border: none;
            border-radius: 8px;
            background-color: #dbe1e0;
            width: 200px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: 2px solid #d46e31;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: #d46e31;
            color: white;
            font-weight: 600;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: #c25e28;
        }

        .btn:disabled {
            background-color: #999;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: #dbe1e0;
            color: black;
        }

        .btn-secondary:hover {
            background-color: #cdd3d2;
        }

        /* Play Section */
        .game-container {
            display: none;
        }

        .game-container.active {
            display: block;
        }

        .card {
            background-color: #dbe1e0;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
        }

        .card-image {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            object-fit: cover;
            margin: 0 auto 20px;
            display: block;
            border: 4px solid #d46e31;
        }

        .progress-bar {
            background-color: #dbe1e0;
            border-radius: 8px;
            height: 20px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            background-color: #d46e31;
            height: 100%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-bottom: 10px;
            font-weight: 600;
        }

        /* Multiple Choice */
        .choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 400px;
            margin: 0 auto;
        }

        .choice-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 15px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: white;
            color: black;
            transition: all 0.2s;
        }

        .choice-btn:hover:not(:disabled) {
            background-color: #d46e31;
            color: white;
        }

        .choice-btn.correct {
            background-color: #4a9c5d;
            color: white;
        }

        .choice-btn.incorrect {
            background-color: #c94444;
            color: white;
        }

        .choice-btn:disabled {
            cursor: default;
        }

        /* Typing Mode */
        .typing-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 15px;
            border: none;
            border-radius: 8px;
            width: 100%;
            max-width: 400px;
            text-align: center;
            background-color: white;
        }

        .typing-input:focus {
            outline: 2px solid #d46e31;
        }

        .input-container {
            max-width: 400px;
            margin: 0 auto;
        }

        .input-hint {
            margin-top: 10px;
            color: #666;
        }

        .typing-feedback {
            margin-top: 15px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
        }

        .typing-feedback.correct {
            background-color: #4a9c5d;
            color: white;
        }

        .typing-feedback.incorrect {
            background-color: #c94444;
            color: white;
        }

        /* Inverse Mode */
        .inverse-prompt {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 20px;
            color: #333;
        }

        .face-choices {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-width: 450px;
            margin: 0 auto;
        }

        .face-choice-btn {
            border: 4px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            background-color: white;
            padding: 10px;
            transition: all 0.2s;
        }

        .face-choice-btn:hover:not(:disabled) {
            border-color: #d46e31;
        }

        .face-choice-btn img {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            object-fit: cover;
            display: block;
        }

        .face-choice-btn.correct {
            border-color: #4a9c5d;
            background-color: #e8f5e9;
        }

        .face-choice-btn.incorrect {
            border-color: #c94444;
            background-color: #ffebee;
        }

        .face-choice-btn:disabled {
            cursor: default;
        }

        /* Result Display */
        .result {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            font-weight: 600;
        }

        .result.correct {
            background-color: #4a9c5d;
            color: white;
        }

        .result.incorrect {
            background-color: #c94444;
            color: white;
        }

        .continue-btn {
            margin-top: 20px;
        }

        /* Batch Complete */
        .batch-complete {
            display: none;
            text-align: center;
        }

        .batch-complete.active {
            display: block;
        }

        .batch-stats {
            background-color: #dbe1e0;
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }

        .batch-stat {
            margin: 10px 0;
        }

        .batch-stat-value {
            font-weight: 700;
            font-size: 24px;
            color: #d46e31;
        }

        .batch-stat-label {
            color: #666;
        }

        /* Statistics Section */
        .stats-card {
            background-color: #dbe1e0;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .stats-card h3 {
            font-weight: 700;
            margin-bottom: 15px;
            color: #d46e31;
        }

        .avg-performance {
            font-size: 32px;
            font-weight: 700;
            color: #d46e31;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #c2cecb;
        }

        th {
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            color: #d46e31;
        }

        th.sorted {
            color: #d46e31;
        }

        .sort-indicator {
            margin-left: 5px;
        }

        tr:hover {
            background-color: rgba(212, 110, 49, 0.1);
        }

        .fail-rate-high {
            color: #c94444;
            font-weight: 600;
        }

        .fail-rate-medium {
            color: #d46e31;
        }

        .fail-rate-low {
            color: #4a9c5d;
        }

        .certificate-btn {
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Game History */
        .game-history-item {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .game-history-date {
            color: #666;
            margin-bottom: 5px;
        }

        .game-history-stats {
            display: flex;
            gap: 20px;
        }

        .no-data {
            text-align: center;
            color: #666;
            padding: 30px;
        }

        /* Configuration Info */
        .config-options {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 20px;
        }

        .config-item {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            background-color: #dbe1e0;
            border-radius: 10px;
            padding: 16px;
        }

        .config-details {
            max-width: 65%;
        }

        .config-details h3 {
            margin-bottom: 8px;
            font-size: 16px;
            color: #d46e31;
        }

        .config-details p {
            color: #666;
            line-height: 1.5;
        }

        .config-control {
            display: flex;
            align-items: center;
            min-width: 200px;
            justify-content: flex-end;
        }

        .config-control input,
        .config-control select {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            background-color: white;
            color: black;
            min-width: 180px;
            transition: outline 0.2s;
        }

        .config-control input:focus,
        .config-control select:focus {
            outline: 2px solid #d46e31;
        }

        .config-control input[type="number"] {
            text-align: center;
            -moz-appearance: textfield;
        }

        .config-control input[type="number"]::-webkit-outer-spin-button,
        .config-control input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .config-control select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
        }

        /* Reset Button */
        .danger-zone {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #b3bfbc;
        }

        .btn-danger {
            background-color: #c94444;
        }

        .btn-danger:hover {
            background-color: #b33a3a;
        }

        /* Employee Loading Status */
        .employee-status {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .employee-status.loading {
            background-color: #fff3cd;
            color: #856404;
        }

        .employee-status.success {
            background-color: #d4edda;
            color: #155724;
        }

        .employee-status.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .employee-status .status-icon {
            font-size: 18px;
        }

        .employee-status .status-text {
            flex: 1;
        }

        .employee-status .status-details {
            font-size: 12px;
            margin-top: 4px;
            opacity: 0.8;
        }

        .spinner {
            width: 18px;
            height: 18px;
            border: 2px solid #856404;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .btn-reload {
            background-color: #17a2b8;
        }

        .btn-reload:hover {
            background-color: #138496;
        }

        .error-details {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 150px;
            overflow-y: auto;
        }

        /* Table wrapper for responsive scrolling */
        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Responsive */
        @media (max-width: 600px) {
            .container {
                padding: 12px;
            }

            .header-logo {
                max-width: 200px;
            }

            .card-image {
                width: 150px;
                height: 150px;
            }

            nav {
                flex-direction: column;
                align-items: stretch;
            }

            nav button {
                padding: 10px 12px;
                font-size: 13px;
            }

            .nav-group {
                justify-content: center;
                flex-wrap: wrap;
            }

            .section {
                padding: 16px;
            }

            .game-history-stats {
                flex-direction: column;
                gap: 5px;
            }

            .config-item {
                flex-direction: column;
            }

            .config-details {
                max-width: 100%;
            }

            .config-control {
                justify-content: flex-start;
                width: 100%;
            }

            .config-control input,
            .config-control select {
                width: 100%;
                min-width: unset;
            }

            /* Stats table responsive */
            .stats-card {
                padding: 12px;
            }

            table {
                font-size: 12px;
            }

            th, td {
                padding: 8px 6px;
            }

            .certificate-btn {
                padding: 4px 8px;
                font-size: 11px;
            }

            .avg-performance {
                font-size: 24px;
            }

            .btn {
                padding: 10px 16px;
                font-size: 13px;
            }

            .choices {
                max-width: 100%;
            }

            .choice-btn {
                padding: 12px;
                font-size: 13px;
            }

            .typing-input {
                max-width: 100%;
                font-size: 14px;
            }

            .batch-stats {
                padding: 15px;
            }

            .batch-stat-value {
                font-size: 20px;
            }

            .face-choices {
                max-width: 100%;
                gap: 10px;
            }

            .face-choice-btn {
                padding: 6px;
            }

            .inverse-prompt {
                font-size: 20px;
            }
        }

        /* Very small screens */
        @media (max-width: 400px) {
            .container {
                padding: 8px;
            }

            .header-logo {
                max-width: 160px;
            }

            .section {
                padding: 12px;
                border-radius: 8px;
            }

            nav button {
                padding: 8px 10px;
                font-size: 12px;
            }

            table {
                font-size: 11px;
            }

            th, td {
                padding: 6px 4px;
            }

            .stats-card h3 {
                font-size: 14px;
            }

            .avg-performance {
                font-size: 20px;
            }

            .choice-btn {
                padding: 10px;
                font-size: 12px;
            }

            .batch-stat-value {
                font-size: 18px;
            }

            .card {
                padding: 20px;
            }

            .face-choices {
                gap: 8px;
            }

            .face-choice-btn {
                padding: 4px;
                border-width: 3px;
            }

            .inverse-prompt {
                font-size: 18px;
                margin-bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="logo-small.png" alt="IPAI Master Socialite" class="header-logo">
        </header>

        <nav>
            <div class="nav-group nav-left">
                <button id="nav-about" class="active" onclick="showSection('about')">About</button>
                <button id="nav-train" onclick="showSection('train')">Train</button>
                <button id="nav-test" onclick="showSection('test')">Test</button>
            </div>
            <div class="nav-group nav-right">
                <button id="nav-stats" onclick="showSection('stats')">Statistics</button>
                <button id="nav-config" onclick="showSection('config')">Configuration</button>
            </div>
        </nav>

        <!-- About Section -->
        <div id="about-section" class="section active">
            <h2>About</h2>
            <p style="margin-bottom: 20px; line-height: 1.6;">
                IPAI Master Socialite helps you learn and remember the faces and names of IPAI employees.
                The game uses repetition to prioritize people whose names you struggle with, helping
                you improve over time. Choose between multiple choice, typing, or inverse mode, and track
                your progress with detailed statistics.
            </p>
            <p style="margin-bottom: 20px; line-height: 1.6;">
                In <em>Training</em>, the game will continue to present face/name combinations until
                you get everyone correct at least once.
            </p>
            <p style="margin-bottom: 20px; line-height: 1.6;">
                In <em>Testing</em>, the game will test your identification abilities for the entire team. Good luck.
            </p>
            <p style="margin-bottom: 25px; line-height: 1.6; color: #666;">
                All your progress and settings are stored locally in your browser. No data is sent to any server.
            </p>

        </div>

        <!-- Configuration Section -->
        <div id="config-section" class="section">
            <h2>Configuration</h2>

            <!-- Employee Data Status -->
            <div id="employee-status" class="employee-status loading">
                <div class="spinner"></div>
                <div class="status-text">
                    <div>Loading employee data...</div>
                </div>
            </div>

            <div class="config-options">
                <div class="config-item">
                    <div class="config-details">
                        <h3>Batch Size</h3>
                        <p>
                            Choose how many employees are included in each training batch. Larger batches cover
                            more people in one session, while smaller batches let you focus on a tighter set
                            before moving on. The minimum is 5.
                        </p>
                    </div>
                    <div class="config-control">
                        <input type="number" id="batch-size" min="5" max="100" value="20">
                    </div>
                </div>

                <div class="config-item">
                    <div class="config-details">
                        <h3>Game Type</h3>
                        <p>
                            Select how you want to answer each prompt. Multiple choice shows a face and asks you to pick the name.
                            Typing requires you to recall and type the name. Inverse shows a name and asks you to pick the correct face
                            from four options. You can switch at any time.
                        </p>
                    </div>
                    <div class="config-control">
                        <select id="game-type">
                            <option value="multiple-choice">Multiple Choice</option>
                            <option value="typing">Type the Name</option>
                            <option value="inverse">Inverse</option>
                        </select>
                    </div>
                </div>

                <div class="config-item">
                    <div class="config-details">
                        <h3>Your Name</h3>
                        <p>
                            Add your name to personalize the learning experience.
                            This stays on your device only.
                        </p>
                    </div>
                    <div class="config-control">
                        <input type="text" id="user-name" placeholder="Enter your name" maxlength="60">
                    </div>
                </div>

                <div class="config-item">
                    <div class="config-details">
                        <h3>Employee Data</h3>
                        <p>
                            Employee data is loaded from ip.ai/ueber-uns. If employees have
                            joined or left, reload to get the latest list.
                        </p>
                    </div>
                    <div class="config-control">
                        <button class="btn btn-reload" id="reload-employees-btn" onclick="reloadEmployees()">Reload Employee List</button>
                    </div>
                </div>
            </div>

            <button class="btn" onclick="saveConfig()">Save Configuration</button>
            <p style="margin-top: 8px; color: #666; font-size: 12px;">
                Configuration is saved locally in your browser.
            </p>

            <div class="danger-zone">
                <p style="margin-bottom: 10px; font-weight: 600;">Danger Zone</p>
                <button class="btn btn-danger" onclick="resetAllData()">Reset All Data</button>
                <p style="margin-top: 8px; color: #666; font-size: 12px;">
                    This will delete all your game progress and statistics from this browser.
                </p>
            </div>
        </div>

        <!-- Train Section -->
        <div id="train-section" class="section">
            <h2>Train</h2>

            <div id="start-game">
                <button class="btn" onclick="startGame('train')">Start Training</button>
            </div>

            <div id="train-game-host">
                <div id="shared-game-ui">
                    <div id="game-container" class="game-container">
                        <div class="progress-text" id="progress-text">Card 1 of 20</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
                        </div>
                        <button id="cancel-training" class="btn btn-secondary" onclick="cancelGame()" style="margin-bottom: 20px; display: none;">
                            Cancel Training
                        </button>

                        <div class="card">
                            <img id="card-image" class="card-image" src="" alt="Employee photo">

                            <!-- Multiple Choice Mode -->
                            <div id="multiple-choice-mode" class="choices">
                                <!-- Filled by JS -->
                            </div>

                            <!-- Typing Mode -->
                            <div id="typing-mode" class="input-container" style="display: none;">
                                <input type="text" id="name-input" class="typing-input" placeholder="Type the name..." autocomplete="off">
                                <p class="input-hint">Press Enter to submit</p>
                                <div id="typing-feedback" class="typing-feedback" style="display: none;"></div>
                            </div>

                            <!-- Inverse Mode -->
                            <div id="inverse-mode" style="display: none;">
                                <div id="inverse-prompt" class="inverse-prompt"></div>
                                <div id="face-choices" class="face-choices">
                                    <!-- Filled by JS -->
                                </div>
                            </div>

                            <div id="result" class="result" style="display: none;">
                                <!-- Filled by JS -->
                            </div>

                            <button id="continue-btn" class="btn continue-btn" style="display: none;" onclick="nextCard()">Continue</button>
                        </div>
                    </div>

                    <div id="batch-complete" class="batch-complete">
                        <h3 id="completion-title">Training Complete!</h3>
                        <div class="batch-stats">
                            <div class="batch-stat">
                                <div class="batch-stat-value" id="final-score">0%</div>
                                <div class="batch-stat-label">Success Rate</div>
                            </div>
                            <div class="batch-stat">
                                <div class="batch-stat-value" id="final-correct">0/0</div>
                                <div class="batch-stat-label">Completion</div>
                            </div>
                        </div>
                        <button class="btn" id="restart-btn" onclick="restartGame()">Train Again</button>
                        <button class="btn btn-secondary" onclick="showSection('stats')">View Statistics</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Section -->
        <div id="test-section" class="section">
            <h2>Test</h2>

            <div id="start-test">
                <button class="btn" onclick="startGame('test')">Start Test</button>
            </div>

            <div id="test-game-host"></div>
        </div>


        <!-- Statistics Section -->
        <div id="stats-section" class="section">
            <h2>Statistics</h2>

            <div class="stats-card">
                <h3>Average Performance (Last 3 Games)</h3>
                <div id="avg-performance" class="avg-performance">--</div>
            </div>

            <div class="stats-card">
                <h3>Training History</h3>
                <div id="game-history">
                    <!-- Filled by JS -->
                </div>
            </div>

            <div class="stats-card">
                <h3>Test History</h3>
                <div id="test-history">
                    <!-- Filled by JS -->
                </div>
            </div>

            <div class="stats-card">
                <h3>Failure Rate by Employee</h3>
                <div id="employee-stats">
                    <!-- Filled by JS -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Employee Data - loaded dynamically from ip.ai/ueber-uns
        let EMPLOYEES = [];
        let employeeLoadError = null;
        const EMPLOYEE_SOURCE_URL = 'https://ip.ai/ueber-uns';

        // Parse employee data from the ip.ai/ueber-uns page HTML
        function parseEmployeesFromHtml(html) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const employees = [];

            // Find all employee grid items - they contain h4 for name and img for photo
            const gridItems = doc.querySelectorAll('.w-grid-item');

            gridItems.forEach(item => {
                // Get the name from h4 element
                const nameEl = item.querySelector('h4');
                if (!nameEl) return;

                const fullName = nameEl.textContent.trim();
                if (!fullName) return;

                // Get the image - look for the actual image (not SVG placeholder)
                const images = item.querySelectorAll('img');
                let imageUrl = null;

                for (const img of images) {
                    const src = img.getAttribute('src') || '';
                    // Skip SVG placeholders
                    if (src.startsWith('data:image/svg')) continue;
                    // Look for wp-content uploads
                    if (src.includes('wp-content/uploads')) {
                        imageUrl = src;
                        break;
                    }
                }

                if (!imageUrl) return;

                // Split name into first and last name
                const nameParts = fullName.split(' ');
                const firstName = nameParts[0];
                const lastName = nameParts.slice(1).join(' ');

                if (firstName && lastName) {
                    employees.push({
                        firstName,
                        lastName,
                        image: imageUrl
                    });
                }
            });

            return employees;
        }

        // Fetch and parse employee data from the website
        async function fetchEmployees() {
            const response = await fetch(EMPLOYEE_SOURCE_URL);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const html = await response.text();
            const employees = parseEmployeesFromHtml(html);

            if (employees.length === 0) {
                throw new Error('No employees found in the page. The page structure may have changed.');
            }

            return employees;
        }

        // Load employees and update the app
        async function loadEmployees() {
            updateEmployeeStatus('loading', 'Loading employee data from ip.ai...');

            try {
                const employees = await fetchEmployees();

                // Add unique IDs and full names
                employees.forEach((emp, idx) => {
                    emp.id = idx;
                    emp.fullName = `${emp.firstName} ${emp.lastName}`;
                });

                EMPLOYEES = employees;
                employeeLoadError = null;

                updateEmployeeStatus('success', `Loaded ${EMPLOYEES.length} employees from ip.ai`);

                // Re-initialize stats for new employees
                initializeEmployeeStats();

                return true;
            } catch (error) {
                employeeLoadError = error;
                const errorMessage = error.message || 'Unknown error';
                updateEmployeeStatus('error', `Failed to load employees: ${errorMessage}`, error);
                return false;
            }
        }

        // Reload employees (called from UI button)
        async function reloadEmployees() {
            const btn = document.getElementById('reload-employees-btn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Reloading...';
            }

            const success = await loadEmployees();

            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Reload Employee List';
            }

            if (success) {
                // Update the batch size max to reflect new employee count
                const batchInput = document.getElementById('batch-size');
                if (batchInput) {
                    batchInput.max = EMPLOYEES.length;
                }
                // Update stats UI if visible
                updateStatsUI();
            }
        }

        // Update the employee status display
        function updateEmployeeStatus(status, message, error = null) {
            const statusEl = document.getElementById('employee-status');
            if (!statusEl) return;

            statusEl.className = `employee-status ${status}`;

            let iconHtml = '';
            if (status === 'loading') {
                iconHtml = '<div class="spinner"></div>';
            } else if (status === 'success') {
                iconHtml = '<span class="status-icon">&#10003;</span>';
            } else if (status === 'error') {
                iconHtml = '<span class="status-icon">&#10007;</span>';
            }

            let detailsHtml = '';
            if (error && status === 'error') {
                const errorDetails = formatErrorDetails(error);
                detailsHtml = `<div class="error-details">${escapeHtml(errorDetails)}</div>`;
            }

            statusEl.innerHTML = `
                ${iconHtml}
                <div class="status-text">
                    <div>${escapeHtml(message)}</div>
                    ${detailsHtml}
                </div>
            `;
        }

        // Format error details for display
        function formatErrorDetails(error) {
            let details = [];

            details.push(`Error: ${error.message || 'Unknown error'}`);

            if (error.name && error.name !== 'Error') {
                details.push(`Type: ${error.name}`);
            }

            // Add common troubleshooting hints
            if (error.message && error.message.includes('Failed to fetch')) {
                details.push('\nPossible causes:');
                details.push('- Network connection issue');
                details.push('- CORS policy blocking the request');
                details.push('- ip.ai website is down or unreachable');
            }

            if (error.message && error.message.includes('HTTP')) {
                details.push('\nThe server returned an error response.');
            }

            details.push(`\nSource URL: ${EMPLOYEE_SOURCE_URL}`);
            details.push(`Time: ${new Date().toLocaleString()}`);

            return details.join('\n');
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize employee stats for all loaded employees
        function initializeEmployeeStats() {
            EMPLOYEES.forEach(emp => {
                if (!stats.employeeStats[emp.id]) {
                    stats.employeeStats[emp.id] = {
                        correct: 0,
                        incorrect: 0,
                        lastSeen: null,
                        lastResult: null
                    };
                }
            });
        }

        // State
        let config = {
            batchSize: 20,
            gameType: 'multiple-choice',
            userName: ''
        };

        let gameState = {
            active: false,
            mode: 'train',
            queue: [],                    // Queue of employees to ask (grows when wrong)
            originalBatchIds: new Set(),  // IDs of original batch employees
            correctlyAnsweredIds: new Set(), // IDs correctly answered at least once
            currentEmployee: null,        // Current employee being shown
            totalAttempts: 0,            // Total questions asked
            correct: 0,                  // Correct answers on first attempt
            totalCount: 0,
            incorrectIds: [],
            results: [],
            answered: false
        };

        let stats = {
            games: [],
            tests: [],
            employeeStats: {}
        };

        let statsBeforeGame = null;

        const STORAGE_KEYS = {
            config: 'ipai_config',
            stats: 'ipai_stats'
        };

        function setLocalData(key, value) {
            localStorage.setItem(key, JSON.stringify(value));
        }

        function getLocalData(key) {
            const value = localStorage.getItem(key);
            if (!value) return null;
            try {
                return JSON.parse(value);
            } catch (e) {
                return null;
            }
        }

        function removeLocalData(key) {
            localStorage.removeItem(key);
        }

        // Cookie helpers
        function setCookie(name, value, days = 365) {
            const expires = new Date(Date.now() + days * 864e5).toUTCString();
            document.cookie = name + '=' + encodeURIComponent(JSON.stringify(value)) + '; expires=' + expires + '; path=/; SameSite=Strict';
        }

        function getCookie(name) {
            const value = document.cookie.split('; ').find(row => row.startsWith(name + '='));
            if (value) {
                try {
                    return JSON.parse(decodeURIComponent(value.split('=')[1]));
                } catch (e) {
                    return null;
                }
            }
            return null;
        }

        function deleteCookie(name) {
            document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;';
        }

        // Load data from storage
        function loadData() {
            const savedConfig = getLocalData(STORAGE_KEYS.config) || getCookie(STORAGE_KEYS.config);
            if (savedConfig) {
                config = { ...config, ...savedConfig };
            }

            const savedStats = getLocalData(STORAGE_KEYS.stats) || getCookie(STORAGE_KEYS.stats);
            if (savedStats) {
                stats = savedStats;
            }
            if (!stats.tests) {
                stats.tests = [];
            }
            if (!stats.games) {
                stats.games = [];
            }
            if (!stats.employeeStats) {
                stats.employeeStats = {};
            }

            // Initialize employee stats (if employees are already loaded)
            initializeEmployeeStats();

            updateConfigUI();
            updateUserNameUI();
        }

        // Save data to storage
        function saveData() {
            setLocalData(STORAGE_KEYS.config, config);
            setLocalData(STORAGE_KEYS.stats, stats);
            setCookie(STORAGE_KEYS.config, config);
            setCookie(STORAGE_KEYS.stats, stats);
        }

        // Update config UI
        function updateConfigUI() {
            document.getElementById('batch-size').value = config.batchSize;
            document.getElementById('game-type').value = config.gameType;
            document.getElementById('user-name').value = config.userName || '';
            updateCurrentConfigDisplay();
        }

        function updateUserNameUI() {
            const input = document.getElementById('user-name');
            if (input) {
                input.value = config.userName || '';
            }
        }

        function updateCurrentConfigDisplay() {
            const configInfo = document.getElementById('current-config');
            if (!configInfo) {
                return;
            }
            const gameTypeLabels = {
                'multiple-choice': 'Multiple Choice',
                'typing': 'Type the Name',
                'inverse': 'Inverse'
            };
            const gameTypeLabel = gameTypeLabels[config.gameType] || 'Multiple Choice';
            configInfo.innerHTML = `
                <div class="config-row">
                    <span>Batch Size:</span>
                    <span><strong>${config.batchSize}</strong></span>
                </div>
                <div class="config-row">
                    <span>Game Type:</span>
                    <span><strong>${gameTypeLabel}</strong></span>
                </div>
                <div class="config-row">
                    <span>Your Name:</span>
                    <span><strong>${config.userName || 'â€”'}</strong></span>
                </div>
            `;
        }

        // Save configuration
        function saveConfig() {
            const maxBatch = EMPLOYEES.length > 0 ? EMPLOYEES.length : 70;
            config.batchSize = Math.min(maxBatch, Math.max(5, parseInt(document.getElementById('batch-size').value) || 20));
            config.gameType = document.getElementById('game-type').value;
            config.userName = document.getElementById('user-name').value.trim();
            saveData();
            updateConfigUI();
            alert('Configuration saved!');
        }

        // Reset all data
        function resetAllData() {
            if (confirm('Are you sure you want to reset all game data? This cannot be undone.')) {
                deleteCookie('ipai_config');
                deleteCookie('ipai_stats');
                removeLocalData(STORAGE_KEYS.config);
                removeLocalData(STORAGE_KEYS.stats);
                stats = { games: [], tests: [], employeeStats: {} };
                config = { batchSize: 20, gameType: 'multiple-choice', userName: '' };
                loadData();
                updateStatsUI();
                alert('All data has been reset.');
            }
        }

        // Navigation
        function updateNavState() {
            const navButtons = document.querySelectorAll('nav button');
            navButtons.forEach(btn => {
                btn.disabled = gameState.active;
            });
        }

        function showSection(section) {
            // Prevent navigation when a session is active
            if (gameState.active) {
                return;
            }

            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));

            document.getElementById(section + '-section').classList.add('active');
            document.getElementById('nav-' + section).classList.add('active');

            if (section === 'stats') {
                updateStatsUI();
            }
            if (section === 'train' || section === 'test') {
                updateGameView(section);
            }
        }

        // Spaced Repetition Algorithm
        function calculatePriority(empId) {
            const empStats = stats.employeeStats[empId];
            if (!empStats) return 1000 + Math.random() * 200; // New employee, high priority

            const total = empStats.correct + empStats.incorrect;
            if (total === 0) return 1000 + Math.random() * 200; // Never seen, high priority

            // Calculate fail rate (0-1)
            const failRate = empStats.incorrect / total;

            // Calculate time since last seen (in hours)
            const now = Date.now();
            const lastSeen = empStats.lastSeen || 0;
            const hoursSinceLastSeen = (now - lastSeen) / (1000 * 60 * 60);

            // Spaced repetition formula:
            // - Higher fail rate = higher priority
            // - Longer time since last seen = higher priority
            // - Recent failure = highest priority

            let priority = 0;

            // Base priority from fail rate (0-500)
            priority += failRate * 500;

            // Time decay factor (0-300)
            // More time = higher priority, capped at ~1 week
            const timeFactor = Math.min(hoursSinceLastSeen / 168, 1) * 300;
            priority += timeFactor;

            // Boost for recent failures
            if (empStats.lastResult === false) {
                priority += 200;
            }

            // Small penalty for very recently seen (within last hour)
            if (hoursSinceLastSeen < 1) {
                priority -= 100;
            }

            // Add small random factor to avoid always same order
            priority += Math.random() * 50;

            return priority;
        }

        function selectBatch(size) {
            // Calculate priority for each employee
            const prioritized = EMPLOYEES.map(emp => ({
                employee: emp,
                priority: calculatePriority(emp.id)
            }));

            // Sort by priority (highest first)
            prioritized.sort((a, b) => b.priority - a.priority);

            // Take top N
            return prioritized.slice(0, size).map(p => p.employee);
        }

        function shuffleArray(items) {
            const array = [...items];
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function attachSharedGameUI(mode) {
            const shared = document.getElementById('shared-game-ui');
            const host = document.getElementById(`${mode}-game-host`);
            if (shared && host && shared.parentElement !== host) {
                host.appendChild(shared);
            }
        }

        function setModeLabels(mode) {
            const cancelButton = document.getElementById('cancel-training');
            const completionTitle = document.getElementById('completion-title');
            const restartBtn = document.getElementById('restart-btn');

            if (mode === 'test') {
                cancelButton.textContent = 'Cancel Test';
                completionTitle.textContent = 'Test Complete!';
                restartBtn.textContent = 'Take Test Again';
            } else {
                cancelButton.textContent = 'Cancel Training';
                completionTitle.textContent = 'Training Complete!';
                restartBtn.textContent = 'Train Again';
            }
        }

        function restartGame() {
            startGame(gameState.mode || 'train');
        }

        // Game Logic
        function startGame(mode) {
            // Check if employees are loaded
            if (EMPLOYEES.length === 0) {
                if (employeeLoadError) {
                    alert('Cannot start game: Employee data failed to load. Please check the Configuration section for details and try reloading.');
                } else {
                    alert('Please wait for employee data to finish loading.');
                }
                return;
            }

            const isTest = mode === 'test';
            statsBeforeGame = isTest ? null : JSON.parse(JSON.stringify(stats));
            const batch = isTest ? shuffleArray([...EMPLOYEES]) : selectBatch(config.batchSize);
            const originalIds = new Set(batch.map(e => e.id));

            if (isTest) {
                const nameValue = (config.userName || '').trim();
                if (!nameValue) {
                    alert('Please add your name in Configuration before starting the test.');
                    showSection('config');
                    const nameInput = document.getElementById('user-name');
                    if (nameInput) {
                        nameInput.focus();
                    }
                    return;
                }
            }

            gameState = {
                active: true,
                mode: mode,
                queue: [...batch],           // Copy of batch as queue
                originalBatchIds: originalIds,
                correctlyAnsweredIds: new Set(),
                currentEmployee: null,
                totalAttempts: 0,
                correct: 0,
                totalCount: batch.length,
                incorrectIds: [],
                results: [],
                answered: false
            };

            setModeLabels(mode);
            attachSharedGameUI(mode);
            updateNavState();

            document.getElementById(mode === 'test' ? 'start-test' : 'start-game').style.display = 'none';
            document.getElementById('game-container').classList.add('active');
            document.getElementById('batch-complete').classList.remove('active');
            document.getElementById('cancel-training').style.display = 'inline-block';

            showCard();
        }

        function showCard() {
            // Get next employee from queue
            const emp = gameState.queue.shift();
            gameState.currentEmployee = emp;
            gameState.answered = false;

            // Update progress
            const total = gameState.totalCount;
            const completed = gameState.mode === 'test' ? gameState.totalAttempts : gameState.correctlyAnsweredIds.size;
            const progress = total === 0 ? 0 : (completed / total) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = gameState.mode === 'test'
                ? `Question ${completed + 1} of ${total}`
                : `${completed} of ${total} learned (${gameState.queue.length + 1} remaining)`;

            // Hide result and continue button
            document.getElementById('result').style.display = 'none';
            document.getElementById('continue-btn').style.display = 'none';

            // Setup game mode
            if (config.gameType === 'inverse') {
                // Hide the card image for inverse mode (we show faces as choices)
                document.getElementById('card-image').style.display = 'none';
                setupInverseMode(emp);
            } else {
                // Show image for other modes
                document.getElementById('card-image').style.display = 'block';
                document.getElementById('card-image').src = emp.image;
                if (config.gameType === 'multiple-choice') {
                    setupMultipleChoice(emp);
                } else {
                    setupTypingMode(emp);
                }
            }
        }

        function setupMultipleChoice(correctEmp) {
            document.getElementById('multiple-choice-mode').style.display = 'flex';
            document.getElementById('typing-mode').style.display = 'none';
            document.getElementById('inverse-mode').style.display = 'none';

            // Get 2 random wrong answers
            const otherEmps = EMPLOYEES.filter(e => e.id !== correctEmp.id);
            const shuffled = otherEmps.sort(() => Math.random() - 0.5);
            const wrongAnswers = shuffled.slice(0, 2);

            // Combine and shuffle
            const choices = [correctEmp, ...wrongAnswers].sort(() => Math.random() - 0.5);

            // Render buttons
            const container = document.getElementById('multiple-choice-mode');
            container.innerHTML = choices.map(emp => `
                <button class="choice-btn" data-id="${emp.id}" onclick="submitChoice(${emp.id})">
                    ${emp.fullName}
                </button>
            `).join('');
        }

        function setupTypingMode(emp) {
            document.getElementById('multiple-choice-mode').style.display = 'none';
            document.getElementById('typing-mode').style.display = 'block';
            document.getElementById('inverse-mode').style.display = 'none';

            const input = document.getElementById('name-input');
            input.value = '';
            input.disabled = false;
            input.focus();

            // Reset feedback
            const feedback = document.getElementById('typing-feedback');
            feedback.style.display = 'none';
            feedback.className = 'typing-feedback';
        }

        function setupInverseMode(correctEmp) {
            document.getElementById('multiple-choice-mode').style.display = 'none';
            document.getElementById('typing-mode').style.display = 'none';
            document.getElementById('inverse-mode').style.display = 'block';

            // Show the employee's name as the prompt
            document.getElementById('inverse-prompt').textContent = correctEmp.fullName;

            // Get 3 random wrong answers
            const otherEmps = EMPLOYEES.filter(e => e.id !== correctEmp.id);
            const shuffled = otherEmps.sort(() => Math.random() - 0.5);
            const wrongAnswers = shuffled.slice(0, 3);

            // Combine and shuffle all 4 options
            const choices = [correctEmp, ...wrongAnswers].sort(() => Math.random() - 0.5);

            // Render face buttons
            const container = document.getElementById('face-choices');
            container.innerHTML = choices.map(emp => `
                <button class="face-choice-btn" data-id="${emp.id}" onclick="submitInverse(${emp.id})">
                    <img src="${emp.image}" alt="Employee photo">
                </button>
            `).join('');
        }

        function submitChoice(chosenId) {
            if (gameState.answered) return;
            gameState.answered = true;

            const emp = gameState.currentEmployee;
            const isCorrect = chosenId === emp.id;
            const isTest = gameState.mode === 'test';

            // Update button styles
            document.querySelectorAll('.choice-btn').forEach(btn => {
                btn.disabled = true;
                const btnId = parseInt(btn.dataset.id);
                if (!isTest) {
                    if (btnId === emp.id) {
                        btn.classList.add('correct');
                    } else if (btnId === chosenId && !isCorrect) {
                        btn.classList.add('incorrect');
                    }
                }
            });

            recordAnswer(emp, isCorrect);
        }

        function submitTyping() {
            if (gameState.answered) return;

            const input = document.getElementById('name-input');
            const answer = input.value.trim().toLowerCase();

            if (!answer) return;

            gameState.answered = true;
            input.disabled = true;

            const emp = gameState.currentEmployee;
            const isTest = gameState.mode === 'test';
            const firstName = emp.firstName.toLowerCase();
            const lastName = emp.lastName.toLowerCase();
            const fullName = emp.fullName.toLowerCase();

            // Check for matches (first name, last name, or full name)
            const isCorrect = answer === fullName ||
                              answer === `${firstName} ${lastName}` ||
                              answer === firstName ||
                              answer === lastName;

            if (!isTest) {
                // Show feedback with name
                const feedback = document.getElementById('typing-feedback');
                feedback.style.display = 'block';
                feedback.className = 'typing-feedback ' + (isCorrect ? 'correct' : 'incorrect');
                feedback.textContent = emp.fullName;
            }

            recordAnswer(emp, isCorrect);
        }

        function submitInverse(chosenId) {
            if (gameState.answered) return;
            gameState.answered = true;

            const emp = gameState.currentEmployee;
            const isCorrect = chosenId === emp.id;
            const isTest = gameState.mode === 'test';

            // Update button styles
            document.querySelectorAll('.face-choice-btn').forEach(btn => {
                btn.disabled = true;
                const btnId = parseInt(btn.dataset.id);
                if (!isTest) {
                    if (btnId === emp.id) {
                        btn.classList.add('correct');
                    } else if (btnId === chosenId && !isCorrect) {
                        btn.classList.add('incorrect');
                    }
                }
            });

            recordAnswer(emp, isCorrect);
        }

        function recordAnswer(emp, isCorrect) {
            gameState.totalAttempts++;
            const isTraining = gameState.mode === 'train';

            // Track correct answers on first attempt only (training)
            const isFirstAttempt = !gameState.correctlyAnsweredIds.has(emp.id);

            if (isTraining) {
                if (isCorrect) {
                    // Mark as correctly answered
                    gameState.correctlyAnsweredIds.add(emp.id);
                    if (isFirstAttempt) {
                        gameState.correct++;
                    }
                } else {
                    // Re-add to queue for another attempt
                    gameState.queue.push(emp);
                }

                gameState.results.push({
                    employeeId: emp.id,
                    correct: isCorrect,
                    firstAttempt: isFirstAttempt
                });

                // Update employee stats (track all attempts)
                const empStats = stats.employeeStats[emp.id];
                if (isCorrect) {
                    empStats.correct++;
                } else {
                    empStats.incorrect++;
                }
                empStats.lastSeen = Date.now();
                empStats.lastResult = isCorrect;
                saveData();
            } else {
                if (isCorrect) {
                    gameState.correct++;
                } else {
                    gameState.incorrectIds.push(emp.id);
                }
            }

            // Show result
            showResult(emp, isCorrect);
        }

        function showResult(emp, isCorrect) {
            const resultDiv = document.getElementById('result');
            resultDiv.style.display = 'none';
            resultDiv.className = 'result';
            resultDiv.innerHTML = '';

            if (gameState.mode === 'test') {
                setTimeout(() => {
                    nextCard();
                }, 300);
                return;
            }

            // Show continue button (delay focus to prevent Enter key from triggering it)
            document.getElementById('continue-btn').style.display = 'inline-block';
            setTimeout(() => document.getElementById('continue-btn').focus(), 100);
        }

        function nextCard() {
            // Check if all employees have been correctly answered
            if (gameState.queue.length === 0) {
                endGame();
            } else {
                showCard();
            }
        }

        function endGame() {
            gameState.active = false;
            statsBeforeGame = null;
            updateNavState();

            if (gameState.mode === 'train') {
                // Calculate success rate (batch size / attempts)
                const batchSize = gameState.originalBatchIds.size;
                const successRate = Math.round((batchSize / gameState.totalAttempts) * 100);

                // Save game to history
                stats.games.unshift({
                    date: Date.now(),
                    successRate: successRate,
                    batchSize: batchSize,
                    attempts: gameState.totalAttempts,
                    gameType: config.gameType
                });

                // Keep only last 50 games
                if (stats.games.length > 50) {
                    stats.games = stats.games.slice(0, 50);
                }

                saveData();

                document.getElementById('final-score').textContent = successRate + '%';
                document.getElementById('final-correct').textContent =
                    `${batchSize} in ${gameState.totalAttempts} attempts`;
            } else {
                const total = gameState.totalCount;
                const successRate = Math.round((gameState.correct / total) * 100);
                stats.tests.unshift({
                    date: Date.now(),
                    score: successRate,
                    correct: gameState.correct,
                    total: total,
                    gameType: config.gameType,
                    userName: config.userName,
                    failedIds: [...gameState.incorrectIds]
                });

                if (stats.tests.length > 50) {
                    stats.tests = stats.tests.slice(0, 50);
                }

                saveData();

                document.getElementById('final-score').textContent = successRate + '%';
                document.getElementById('final-correct').textContent =
                    `${gameState.correct} of ${total} correct`;
            }

            // Show batch complete
            document.getElementById('game-container').classList.remove('active');
            document.getElementById('batch-complete').classList.add('active');
            document.getElementById('cancel-training').style.display = 'none';
        }

        function cancelGame() {
            if (!gameState.active) return;
            const label = gameState.mode === 'test' ? 'test' : 'training';
            const shouldCancel = confirm(`Cancel this ${label} run? Your progress in this session will be lost.`);
            if (!shouldCancel) return;

            if (statsBeforeGame) {
                stats = JSON.parse(JSON.stringify(statsBeforeGame));
                saveData();
                updateStatsUI();
            }

            resetGameState();
            resetGameUI(gameState.mode);
            updateNavState();
        }

        function resetGameState() {
            gameState = {
                active: false,
                mode: gameState.mode || 'train',
                queue: [],
                originalBatchIds: new Set(),
                correctlyAnsweredIds: new Set(),
                currentEmployee: null,
                totalAttempts: 0,
                correct: 0,
                totalCount: 0,
                incorrectIds: [],
                results: [],
                answered: false
            };
            statsBeforeGame = null;
        }

        function resetGameUI(mode) {
            document.getElementById('game-container').classList.remove('active');
            document.getElementById('batch-complete').classList.remove('active');
            const startId = mode === 'test' ? 'start-test' : 'start-game';
            const startBlock = document.getElementById(startId);
            if (startBlock) {
                startBlock.style.display = 'block';
            }
            document.getElementById('cancel-training').style.display = 'none';
        }

        function updateGameView(mode) {
            attachSharedGameUI(mode);
            if (gameState.active && gameState.mode === mode) {
                document.getElementById(mode === 'test' ? 'start-test' : 'start-game').style.display = 'none';
                document.getElementById('game-container').classList.add('active');
                document.getElementById('cancel-training').style.display = 'inline-block';
                document.getElementById('batch-complete').classList.remove('active');
                setModeLabels(mode);
            } else {
                resetGameUI(mode);
            }
        }

        // Statistics UI
        function updateStatsUI() {
            updateAveragePerformance();
            updateGameHistory();
            updateTestHistory();
            updateEmployeeStats();
        }

        function updateAveragePerformance() {
            const avgDiv = document.getElementById('avg-performance');
            const lastThree = stats.games.slice(0, 3);

            if (lastThree.length === 0) {
                avgDiv.textContent = '--';
                return;
            }

            // Calculate average success rate
            const avg = Math.round(lastThree.reduce((sum, g) => sum + (g.successRate || g.score || 0), 0) / lastThree.length);
            avgDiv.textContent = avg + '%';
        }

        function updateGameHistory() {
            const container = document.getElementById('game-history');

            if (stats.games.length === 0) {
                container.innerHTML = '<div class="no-data">No training sessions yet</div>';
                return;
            }

            container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Date/Time</th>
                                <th>Success Rate</th>
                                <th>Batch</th>
                                <th>Attempts</th>
                                <th>Mode</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${stats.games.slice(0, 10).map(game => {
                                const date = new Date(game.date);
                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                const typeLabels = { 'multiple-choice': 'MC', 'typing': 'Type', 'inverse': 'Inv' };
                                const typeLabel = typeLabels[game.gameType] || 'MC';
                                // Support both old format (score) and new format (successRate)
                                const successRate = game.successRate !== undefined ? game.successRate : (game.score || 0);
                                const batchSize = game.batchSize !== undefined ? game.batchSize : (game.total || 0);
                                const attempts = game.attempts || batchSize;

                                return `
                                    <tr>
                                        <td>${dateStr}</td>
                                        <td><strong>${successRate}%</strong></td>
                                        <td>${batchSize}</td>
                                        <td>${attempts}</td>
                                        <td>${typeLabel}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function updateTestHistory() {
            const container = document.getElementById('test-history');

            if (!stats.tests || stats.tests.length === 0) {
                container.innerHTML = '<div class="no-data">No tests taken yet</div>';
                return;
            }

            container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Date/Time</th>
                                <th>Score</th>
                                <th>Correct</th>
                                <th>Mode</th>
                                <th>Certificate</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${stats.tests.slice(0, 10).map((test, index) => {
                                const date = new Date(test.date);
                                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                                const typeLabels = { 'multiple-choice': 'MC', 'typing': 'Type', 'inverse': 'Inv' };
                                const typeLabel = typeLabels[test.gameType] || 'MC';
                                const score = test.score !== undefined ? test.score : Math.round((test.correct / test.total) * 100);
                                return `
                                    <tr>
                                        <td>${dateStr}</td>
                                        <td><strong>${score}%</strong></td>
                                        <td>${test.correct}/${test.total}</td>
                                        <td>${typeLabel}</td>
                                        <td><button class="btn btn-secondary certificate-btn" onclick="downloadTestCertificate(${index})">Download PDF</button></td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        let employeeSortColumn = 'failRate';
        let employeeSortAsc = false;

        function updateEmployeeStats() {
            const container = document.getElementById('employee-stats');

            // Prepare data
            const data = EMPLOYEES.map(emp => {
                const empStats = stats.employeeStats[emp.id] || { correct: 0, incorrect: 0 };
                const total = empStats.correct + empStats.incorrect;
                const failRate = total > 0 ? (empStats.incorrect / total) * 100 : 0;

                return {
                    id: emp.id,
                    firstName: emp.firstName,
                    lastName: emp.lastName,
                    correct: empStats.correct,
                    incorrect: empStats.incorrect,
                    total: total,
                    failRate: failRate
                };
            });

            // Sort (keep employees with no data at bottom when sorting by failRate)
            data.sort((a, b) => {
                // When sorting by failRate, keep no-data employees at the bottom
                if (employeeSortColumn === 'failRate') {
                    if (a.total === 0 && b.total === 0) return 0;
                    if (a.total === 0) return 1;  // a goes to bottom
                    if (b.total === 0) return -1; // b goes to bottom
                }

                let valA = a[employeeSortColumn];
                let valB = b[employeeSortColumn];

                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }

                if (employeeSortAsc) {
                    return valA < valB ? -1 : valA > valB ? 1 : 0;
                } else {
                    return valA > valB ? -1 : valA < valB ? 1 : 0;
                }
            });

            const sortIndicator = (col) => {
                if (employeeSortColumn === col) {
                    return `<span class="sort-indicator">${employeeSortAsc ? '^' : 'v'}</span>`;
                }
                return '';
            };

            const sortedClass = (col) => employeeSortColumn === col ? 'sorted' : '';

            container.innerHTML = `
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th class="${sortedClass('firstName')}" onclick="sortEmployees('firstName')">First Name${sortIndicator('firstName')}</th>
                                <th class="${sortedClass('lastName')}" onclick="sortEmployees('lastName')">Last Name${sortIndicator('lastName')}</th>
                                <th class="${sortedClass('correct')}" onclick="sortEmployees('correct')">Correct${sortIndicator('correct')}</th>
                                <th class="${sortedClass('incorrect')}" onclick="sortEmployees('incorrect')">Wrong${sortIndicator('incorrect')}</th>
                                <th class="${sortedClass('failRate')}" onclick="sortEmployees('failRate')">Fail Rate${sortIndicator('failRate')}</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.map(d => {
                                let failClass = '';
                                if (d.total > 0) {
                                    if (d.failRate >= 50) failClass = 'fail-rate-high';
                                    else if (d.failRate >= 25) failClass = 'fail-rate-medium';
                                    else failClass = 'fail-rate-low';
                                }
                                return `
                                    <tr>
                                        <td>${d.firstName}</td>
                                        <td>${d.lastName}</td>
                                        <td>${d.correct}</td>
                                        <td>${d.incorrect}</td>
                                        <td class="${failClass}">${d.total > 0 ? d.failRate.toFixed(0) + '%' : '-'}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function sortEmployees(column) {
            if (employeeSortColumn === column) {
                employeeSortAsc = !employeeSortAsc;
            } else {
                employeeSortColumn = column;
                employeeSortAsc = column === 'firstName' || column === 'lastName';
            }
            updateEmployeeStats();
        }

        function downloadTestCertificate(testIndex) {
            const test = stats.tests[testIndex];
            if (!test) return;

            let name = (test.userName || config.userName || '').trim();
            if (!name) {
                name = prompt('Enter your name for the certificate:');
            }
            if (!name) return;

            const scorePercent = test.score !== undefined ? test.score : Math.round((test.correct / test.total) * 100);
            const scoreText = `${test.correct}/${test.total} (${scorePercent}%)`;

            const failedIds = Array.isArray(test.failedIds) ? test.failedIds : [];
            const recommendations = shuffleArray(failedIds)
                .slice(0, 5)
                .map(id => EMPLOYEES.find(emp => emp.id === id))
                .filter(Boolean)
                .map(emp => emp.fullName);

            const certificateBlob = generateCertificatePdf({
                name,
                scoreText,
                recommendations
            });

            const url = URL.createObjectURL(certificateBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `IPAI_Test_Certificate_${name.replace(/\s+/g, '_')}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function generateCertificatePdf({ name, scoreText, recommendations }) {
            const header = '%PDF-1.4\n';
            const lines = [
                { text: 'IPAI Master Socialite Test Certificate', size: 18, x: 72, y: 720 },
                { text: `Name: ${name}`, size: 14, x: 72, y: 680 },
                { text: `Test Score: ${scoreText}`, size: 14, x: 72, y: 650 },
                { text: 'Coffee suggestions (people you missed):', size: 12, x: 72, y: 610 }
            ];

            if (recommendations.length === 0) {
                lines.push({ text: 'No missed names this time. Great job!', size: 12, x: 90, y: 585 });
            } else {
                recommendations.forEach((person, idx) => {
                    lines.push({ text: `${idx + 1}. ${person}`, size: 12, x: 90, y: 585 - (idx * 18) });
                });
            }

            const content = ['BT'];
            lines.forEach(line => {
                content.push(`/F1 ${line.size} Tf`);
                content.push(`1 0 0 1 ${line.x} ${line.y} Tm`);
                content.push(`(${escapePdfText(line.text)}) Tj`);
            });
            content.push('ET');

            const contentStream = content.join('\n');

            const objects = [];
            objects.push('1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n');
            objects.push('2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n');
            objects.push('3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n');
            objects.push(`4 0 obj\n<< /Length ${contentStream.length} >>\nstream\n${contentStream}\nendstream\nendobj\n`);
            objects.push('5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n');

            let pdfBody = header;
            const offsets = [0];
            objects.forEach(obj => {
                offsets.push(pdfBody.length);
                pdfBody += obj;
            });

            const xrefStart = pdfBody.length;
            let xref = `xref\n0 ${offsets.length}\n`;
            xref += '0000000000 65535 f \n';
            offsets.slice(1).forEach(offset => {
                xref += `${String(offset).padStart(10, '0')} 00000 n \n`;
            });
            const trailer = `trailer\n<< /Size ${offsets.length} /Root 1 0 R >>\nstartxref\n${xrefStart}\n%%EOF`;

            const pdf = pdfBody + xref + trailer;
            return new Blob([pdf], { type: 'application/pdf' });
        }

        function escapePdfText(text) {
            return text
                .replace(/\\/g, '\\\\')
                .replace(/\(/g, '\\(')
                .replace(/\)/g, '\\)');
        }

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            if (!gameState.active) return;

            if (e.key === 'Enter') {
                e.preventDefault();
                if (config.gameType === 'typing' && !gameState.answered) {
                    submitTyping();
                } else if (gameState.answered) {
                    nextCard();
                }
            }
        });

        // Initialize
        async function initialize() {
            // Load employees first, then load user data
            await loadEmployees();
            loadData();

            // Update batch size max based on loaded employees
            const batchInput = document.getElementById('batch-size');
            if (batchInput && EMPLOYEES.length > 0) {
                batchInput.max = EMPLOYEES.length;
            }
        }

        initialize();
    </script>
    <!-- simpleanalytics.com (privacy-first, EU-hosted analytics) -->
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</body>
</html>
